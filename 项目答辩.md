项目答辩

## **项目名称：**爱否商城-高品质的二手商城

### **项目介绍:**

爱否商城，精选极限性能二手电子科技产品，每天限时特价、限量秒杀等优惠，让你轻松追求高品质生活，不辜负你的每一份信任。 

### **技术栈：**

vue2.0 + vue-cli + vuex + vue.router + mint-ui + axios 

使用vue全家桶进行开发，路由跳转使用vue-router，请求数据使用官方推荐axios插件，使用es6进行开发

### 移动端适配：

rem：将px替换成rem，动态修改html的font-size适配。它可以很好的根据根元素的字体大小来进行变化，从而达到各种屏幕基本一致的效果体验。举例说明，在320px宽度的屏幕下font-size的默认值是16px，得到的换算rem的倍数为320/16=20;1rem等于16px；

由于是web-app，因此需要兼容不同设备的屏幕大小，在这里使用的手淘推荐的flexble方案，通过动态的设置根元素的font-size大小，使用rem来进行移动端适配。在这里由于使用rem进行布局，而通常给我们的设计稿是640px，750px为标准，在编写的时候把px大小转换为rem也比较麻烦，因此这里使用了postcss-px2rem，在编译的时候会将px自动转换成为rem



#### 跨域处理：

因为自己写的后台，前端运行的地址和接口的访问地址并不一样，浏览器的同源策略使得我们不得不处理跨域，因此可以对跨域进行简单处理。用反向代理

1.开发模式下：要在config下的index.js进行配置。

在进行接口请求的时候在路径前面加上/api就可以了，编译后会将/api重写为线上的接口地址

```
proxyTable: {
     '/api': {  
         target: 'http://test.happymmall.com', //源地址
         changeOrigin: true, //改变源
         pathRewrite: {
             '^/api': '' //路径重写
         }
     }
 }
```

2.生产模式下：使用nignx，要在远程服务器上安装nignx，然后在nignx.conf文件内配置location就可以了

#### 业务功能：

 首页模块，分类模块，购物车模块,  我的模块，注册登录模块

#### 模块内功能:

首页模块:  搜索, 进度条,路由切换，商品渲染, 商品详情渲，轮播图，数量加减，

分类模块:  搜索, 商品分类分页及渲染

购物车模块：购物车渲染及列表, 购物车商品加减, 删除, 单选, 多选, 全选, 结算总价，支付

个人中心模块: 退出登录

注册登录模块： 登陆拦截功能，注册(验证码),  登录, ，修改密码

​      

##### **首页模块**:

###### 一、搜索：

(根据商品名称搜索)

简单的说，往后台发送一个关键词到后端，后端对已有的数据在数据库进行一个筛选，如果有与关键词相同的，就是找到结果，并将这个结果返回，前台渲染页面，搜索渲染要渲染到另外一个页面，那么就可以用路由传值，query将搜索的关键词传到要渲染的页面，然后就在这个页面请求要搜索的数据

eg：1,根据input的value值来筛选数组中的数据

​        2,声明一个空数组用来存放数据

​        3,循环数组中的每一项,然后判断数组中每一项的商品名称是否包含input框里面的value值,如果包含,则匹配成功,把数据放到刚刚声明的空数组中,渲染页面

###### 二、进度条：

下载nprogress===》 在mina.js中引入     import NProgress from 'nprogress'

###### 三、路由切换：

1.使用router-link来导航，传入to属性

2.router-view来作为出口

3.在router的index.js文件里定义路由，每个路由都映射一个组件

4.将router挂载到根实例中

###### 四、商品渲染：      

1.在data里创建一个空数组接收后台传过来的数据

2.用axios获取后台json里面的数据

3.用刚才创建的新数组接收将后台传过来的数据，将传过来的数据转换成数组，获取json里面的那条数据，就找到对应的数组（this.home = JSON.parse(res.data.data).home）

4.用v-for循环数组home渲染页面

######  五、商品详情渲染：

1,点击事件的时候传实参id,在函数内部获取点击当前的id所在的对象,用编程式导航this.$router.push(（query用query的方式传id）)把获取到的对象传过去.

2.在商品详情页面用this.$route.query.id接收主页传过来的id

3.用axios将id传到后台根据id找对应的数据

4.创建一个空数组，接收后台通过id传过来的数据

5.用刚才创建的新数组接收将后台传过来的数据，获取json里面的那条数据，就找到对应的数组（ let arr = res.data，this.x = arr[0].content）

6.用v-for循环数组x渲染页面

###### 六、轮播图：

1.用mint-ui做轮播图

2.用swiper：

商品详情页需要轮播图，所以我使用mint-ui封装了一个轮播图组建，这件的话轮播图就可以复用

npm下载安装mint-ui===》将mint-ui插件中的css样式导入===》建立一个专属于轮播图的组建===》

 在methods方法中初始化一个swiper插件，官网上会有参数，按自己的需求来进行调用，比如autoplay，speed，loop，小圆点之类的基本参数===》在mounted钩子函数里面调用===》封装好组建哪里需要就调用

​              

######  七、商品详情渲染里面的数量加减

​             

##### **分类模块:**

###### 一、搜索：

 (根据商品名称搜索)

1.根据input的value值来筛选数组中的数据

2.声明一个空数组用来存放数据

3.循环数组中的每一项,然后判断数组中每一项的商品名称是否包含input框里面的value值,如果包含,则匹配成功,把数据放到刚刚声明的空数组中,渲染页面

######  二、商品分类分页及渲染模块

​            

##### **购物车模块:**

（用vuex做购物车）

一、购物车渲染及列表

1.新建仓库store文件夹和index.js文件,引入vuex, 

2.新建仓库 new Vuex.Store({ }),在state中新建数组lists,在getters中新建一个函数返回这个数组,

3.详情页面点击加入购物车时,在点击事件内部,新建一个对象,将需要的数据放到对象中,通过this.$store.commit(),将对象传入vuex的mutations对应的函数内,有两个参数state,payload,payload就是传过来的对象

4.在mutations的函数内部,将刚才传过来的对象payload添加到state中新建的数组lists中

5.在购物车页面计算属性中用辅助函数mapgetters接收刚才放入lists数组中的数据

6.用v-for循环数组lists渲染页面

###### 二、购物车商品加减

​               

###### 三、删除

页面中删除：1.通过id删除， 找数组里面的id，删除第一个

​                       2.用this.$store.commit，将id传入到vuex中delet函数中将sessionStorage中的 数据也删除                             

```
    del(id){
        this.lists.splice(id,1)//用splice删除一个,根据索引删除,
        this.$store.commit("delet",id)
    }
```

vuex中删除：1.id是刚才购物车页面传过来的，

​                        2.用some遍历lists，判断

```
    delet(state,id){//id是shopping传过来的数据
        //some用于检测数组中的元素是否满足指定条件 
        //如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。
        //item代表lists中的数据,id代表lists中的id
        state.lists.some((item,id)=>{
            //item是代表的是lists,id代表的是购物车的id
            if(item==id){ //判断item和id的值是否相等,相等就删除  
            state.lists.splice(id,1)//splice删除一条数据
            }
        })
    }
```



###### 四、单选

页面中:

​         设置加入购物车的时候默认被选中的状态,给个onchange事件 传参索引

​         函数内部取反 this.goodlist[index].checked=!this.goodlist[index].checked 并传给vuex mutaions中的对应函数内  数组some方法,判断checked的状态,取反,返回

vuex中:         

```vue
   //state默认,payload代表的就是shopping里面的this.lists[index],用payload名字来接收
    pdateCheck(state,payload){
        state.lists.some(item => {   //用some遍历lists
            //item.checked是lists里面的,payload.checked是shopping传过来的
                if (item.checked == payload.checked) {
                //点击单选按钮取消的时候,全选按钮去掉
                item.checked == !payload.checked;
                return true;
            }
        })
    }
```



######  五、全选 

A):checked=”changeCheckedAll”  changeCheckedAll是计算属性中的布尔值,

​     在计算属性中判断 (有三种情况)

​     1,如果数组的长度==0, 返回false, (全选框是不选中的状态)			 

​     2,循环遍历数组,如果有一项的checked状态为false的时候,return  false(全选框是非选中的状态)

​     3.其他情况返回true (全选框是选中状态)

B):全选框的点击事件

​	 获取全选框现在的状态.如果是true的时候,点击,每一项的选个框为false

```
   if (this.changeCheckAll) {//当全选框checked=true是选中状态的时候 点击全选 全选框取消
         this.goodsList.forEach(item => (item.checked = false));
   } else {
         this.goodsList.forEach(item => (item.checked = true));
   }
```



###### 六、结算总价

数组调用filter( )方法筛选,返回被选中的对象(item.checked)组成的数组,接着调用reduce ((pre,cur )=>{},)方法,接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。(可以求和,可以去重)

```
    totalPrice() {
        return this.lists.filter(item => { 
            return item.checked;
        }).reduce((v1, item) => {//用上一次的价格+商品在添加的价格+数量=总价
            return v1 + item.jiage * item.num ;
        }, 0);//0代表初始值
    },
```

​          

##### **个人中心模块:**

###### 一、订单

​          

###### 二、待收发货及评价

###### 三、收藏

###### 四、地址

###### 五、红包

###### 六、推荐

###### 七、资金

###### 八、帮助

###### 九、修改密码



##### **注册登录模块:**

###### 一、登陆拦截功能

1.首先在定义路由的时候就需要多添加一个自定义字段isLogin，用于判断访问该路由是否需要登录

2.meta:{ isLogin:true}//添加该字段，表示进入这个路由是需要登录的

3.全局前置守卫，beforeEach是router的钩子函数，该函数在进入每个网页之前调用，该函数接受三个参数：

​               1.from：即将离开路由

​               2. to：即将要跳转的路由

​               3. next：跳转方法。在beforeEach 函数中作为结束语句调用，以实现网页跳转。(function函数) 调用next() 进行下一个钩子

​               next() 无参 进行 下一个钩子函数

​               next({ path:'/xxx' ,query:{} }) 携带参数跳转xxx页面

​               还有一种情况是如果当前token失效了，但是token依然保存在本地。这时候你去访问需要登录的权限的路由时，实际上应该让用户重新登陆

​                这时候就需要结合http拦截器+后端接口返回的http状态码来判断

###### 二、注册

先验证手机号、昵称、密码等格式对不对，然后向后台发起请求，后台从数据库里验证手机号有没有注册，如果有就返回已注册，没有注册就返回注册成功并跳转到登录界面

###### 三、登录

1.验证用户手机号是否正确

2.点击获取验证码，此时将手机号发送给后台

3.后台生成验证码，并将手机号和验证码发送给第三方短信平台

4.短信平台向改手机号用户发送验证码

5.用户填写验证码，并点击登录，即将手机号和验证码发送给后台

6.后台验证手机号返回登录成功的信息 和失败信息，成功则token，失败则401

7.如果返回token我们则把token存储在localStorage和sessionStorage都可以

8.登陆成功

之后客户端再次发送网络请求（一般不是登录请求）的时候，就会将这个token值附带到参数中发送给服务器

服务器接收到客户端的请求之后，取出token值与保存在本地（数据库）中的token值做对比

如果两个token值相同，说明用户处于登录状态

如果没有这个token值，说明没有登录成功

如果token值不同：说明原来的登录信息已经失效，让用户重新登陆。后端会更新token

###### 四、退出登录

将token清楚，localStorage.removeItem('key')

localStorage.clear()将localstorage里都清除

###### 五、修改密码



### 接口：

41个接口

产品接口：产品列表、产品搜索、产品详情、新增产品

统计接口：统计商品和订单数量

用户接口：用户列表

产品种类接口：获取品类节点

订单接口：订单列表、按订单号查询、订单详情、订单状态

订单接口：创建订单、获取订单的商品信息、订单详情、取消订单、

收货地址接口：添加地址、删除地址、登录状态更新地址、地址列表、查看具体地址

用户接口：登录、注册、验证码、修改密码、退出登录、获取用户详细信息、登录状态更新个人信息、登录状态中修改密码、忘记密码

购物车接口：购物车列表、添加商品、改变产品数量、删除商品、选中某个商品、取消选中、全选、取消全选

支付接口：支付、查询支付状态、支付宝回调

### 主要页面：

首页

产品分类页面：搜索商品跳转、类别筛选、销量、新品、价格、信用

注册/登录页面

商品搜索列表页面

商品详情列表页面

购物车页面：全选多选、数量加减、价格结算

确认订单界面

支付界面

用户界面

我的订单界面

我的收藏页面

收货地址页面

我的积分界面

我的推荐界面

我的资金界面

使用帮助界面

修改密码界面

